# .github/workflows/generate-max-orchestrator.yml
name: Generate MAX Orchestrator

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Create orchestrator structure
        run: |
          mkdir -p max-orchestrator/{src/{modules,state,graph,user,io,autogen,experience,orchestrator},public/icons,data}

      - name: Write core config files
        run: |
          cat > max-orchestrator/.gitignore << 'EOF'
node_modules
dist
.DS_Store
*.log
.env
EOF

          cat > max-orchestrator/tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist",
    "rootDir": "src",
    "declaration": true
  },
  "include": ["src/**/*"]
}
EOF

          cat > max-orchestrator/package.json << 'EOF'
{
  "name": "max-orchestrator",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "build": "tsc"
  },
  "devDependencies": {
    "typescript": "^5.5.4"
  }
}
EOF

      - name: Write index and module layer
        run: |
          cat > max-orchestrator/src/index.ts << 'EOF'
import { MAXOrchestrator } from "./orchestrator/MAXOrchestrator";
import { MAXMemoryGraph } from "./graph/MAXMemoryGraph";
import { MAXStateEngine } from "./state/MAXStateEngine";
import { MAXUserModel } from "./user/MAXUserModel";
import { MAXIOProtocol } from "./io/MAXIOProtocol";
import { MAXAutogenerator } from "./autogen/MAXAutogenerator";
import { MAXExperienceLayer } from "./experience/MAXExperienceLayer";
import { ModuleRegistry } from "./modules/ModuleRegistry";

const registry = new ModuleRegistry();
const graph = new MAXMemoryGraph();
const stateEngine = new MAXStateEngine();
const userModel = new MAXUserModel(graph);
const io = new MAXIOProtocol();
const autogen = new MAXAutogenerator(registry, graph);
const experience = new MAXExperienceLayer(graph, stateEngine, userModel);

export const orchestrator = new MAXOrchestrator(
  registry,
  graph,
  stateEngine,
  userModel,
  io,
  autogen,
  experience
);

export * from "./modules/types";
export * from "./state/types";
export * from "./user/types";
export * from "./graph/types";
export * from "./io/types";
export * from "./autogen/types";
export * from "./experience/types";
EOF

          cat > max-orchestrator/src/modules/types.ts << 'EOF'
export type ModuleId = string;

export interface ModuleInput {
  type: string;
  payload: unknown;
  userId: string;
  sessionId: string;
  runId?: string;
  metadata?: Record<string, unknown>;
}

export interface ModuleOutput {
  type: string;
  payload: unknown;
  userId: string;
  sessionId: string;
  runId: string;
  stateDelta?: Record<string, unknown>;
  tags?: string[];
}

export interface ModuleContext {
  userId: string;
  sessionId: string;
  runId: string;
  state: Record<string, unknown>;
  dfpState: string;
  timestamp: string;
}

export interface MAXModule {
  id: ModuleId;
  version: string;
  accepts: string[];
  produces: string[];
  tags?: string[];
  run(input: ModuleInput, context: ModuleContext): Promise<ModuleOutput>;
}
EOF

          cat > max-orchestrator/src/modules/ModuleRegistry.ts << 'EOF'
import { MAXModule, ModuleId } from "./types";

export class ModuleRegistry {
  private modules: Map<ModuleId, MAXModule> = new Map();

  register(module: MAXModule): void {
    this.modules.set(module.id, module);
  }

  get(id: ModuleId): MAXModule | undefined {
    return this.modules.get(id);
  }

  list(): MAXModule[] {
    return Array.from(this.modules.values());
  }

  findByTag(tag: string): MAXModule[] {
    return this.list().filter((m) => m.tags?.includes(tag));
  }

  findByInputType(type: string): MAXModule[] {
    return this.list().filter((m) => m.accepts.includes(type));
  }

  findByOutputType(type: string): MAXModule[] {
    return this.list().filter((m) => m.produces.includes(type));
  }
}
EOF

      - name: Write state engine
        run: |
          cat > max-orchestrator/src/state/types.ts << 'EOF'
export type DFPStateId = string;

export interface DFPState {
  id: DFPStateId;
  label: string;
  description?: string;
  priority: number;
  traits: Record<string, number>;
}

export interface StateTransition {
  from: DFPStateId;
  to: DFPStateId;
  condition: string;
  weight: number;
}

export interface StateClassificationInput {
  signals: Record<string, number>;
  tags?: string[];
}

export interface StateClassificationResult {
  stateId: DFPStateId;
  confidence: number;
  traits: Record<string, number>;
}

export interface StateRoutingRule {
  stateId: DFPStateId;
  preferredModuleTags: string[];
  fallbackModuleTags?: string[];
}
EOF

          cat > max-orchestrator/src/state/MAXStateEngine.ts << 'EOF'
import {
  DFPState,
  DFPStateId,
  StateClassificationInput,
  StateClassificationResult,
  StateRoutingRule,
  StateTransition
} from "./types";

export class MAXStateEngine {
  private states: Map<DFPStateId, DFPState> = new Map();
  private transitions: StateTransition[] = [];
  private routingRules: StateRoutingRule[] = [];

  registerState(state: DFPState): void {
    this.states.set(state.id, state);
  }

  registerTransition(transition: StateTransition): void {
    this.transitions.push(transition);
  }

  registerRoutingRule(rule: StateRoutingRule): void {
    this.routingRules.push(rule);
  }

  classify(input: StateClassificationInput): StateClassificationResult {
    const traits = input.signals;
    const defaultState = Array.from(this.states.values()).sort(
      (a, b) => b.priority - a.priority
    )[0];

    return {
      stateId: defaultState?.id ?? "default",
      confidence: 0.5,
      traits
    };
  }

  nextState(current: DFPStateId, input: StateClassificationInput): DFPStateId {
    const candidates = this.transitions.filter((t) => t.from === current);
    if (candidates.length === 0) return current;
    const sorted = candidates.sort((a, b) => b.weight - a.weight);
    return sorted[0].to;
  }

  getRoutingForState(stateId: DFPStateId): StateRoutingRule | undefined {
    return this.routingRules.find((r) => r.stateId === stateId);
  }
}
EOF

      - name: Write graph layer
        run: |
          cat > max-orchestrator/src/graph/types.ts << 'EOF'
export type NodeId = string;

export interface GraphNode {
  id: NodeId;
  type: string;
  label?: string;
  data?: Record<string, unknown>;
}

export interface GraphEdge {
  from: NodeId;
  to: NodeId;
  type: string;
  weight?: number;
  data?: Record<string, unknown>;
}
EOF

          cat > max-orchestrator/src/graph/MAXMemoryGraph.ts << 'EOF'
import { GraphNode, GraphEdge, NodeId } from "./types";

export class MAXMemoryGraph {
  private nodes: Map<NodeId, GraphNode> = new Map();
  private edges: GraphEdge[] = [];

  addNode(node: GraphNode): void {
    this.nodes.set(node.id, node);
  }

  addEdge(edge: GraphEdge): void {
    this.edges.push(edge);
  }

  getNode(id: NodeId): GraphNode | undefined {
    return this.nodes.get(id);
  }

  getNeighbors(id: NodeId): GraphNode[] {
    const neighborIds = this.edges
      .filter((e) => e.from === id)
      .map((e) => e.to);
    return neighborIds
      .map((nid) => this.nodes.get(nid))
      .filter((n): n is GraphNode => Boolean(n));
  }

  findByType(type: string): GraphNode[] {
    return Array.from(this.nodes.values()).filter((n) => n.type === type);
  }
}
EOF

      - name: Write user model
        run: |
          cat > max-orchestrator/src/user/types.ts << 'EOF'
export type UserId = string;
export type SessionId = string;
export type RunId = string;

export interface UserProfile {
  id: UserId;
  traits: Record<string, number>;
  tags: string[];
  createdAt: string;
  updatedAt: string;
}

export interface SessionContext {
  id: SessionId;
  userId: UserId;
  startedAt: string;
  lastActiveAt: string;
  metadata?: Record<string, unknown>;
}
EOF

          cat > max-orchestrator/src/user/MAXUserModel.ts << 'EOF'
import { MAXMemoryGraph } from "../graph/MAXMemoryGraph";
import { SessionContext, UserId, UserProfile, SessionId } from "./types";

export class MAXUserModel {
  private graph: MAXMemoryGraph;
  private users: Map<UserId, UserProfile> = new Map();
  private sessions: Map<SessionId, SessionContext> = new Map();

  constructor(graph: MAXMemoryGraph) {
    this.graph = graph;
  }

  upsertUser(profile: UserProfile): void {
    this.users.set(profile.id, profile);
  }

  getUser(id: UserId): UserProfile | undefined {
    return this.users.get(id);
  }

  upsertSession(session: SessionContext): void {
    this.sessions.set(session.id, session);
  }

  getSession(id: SessionId): SessionContext | undefined {
    return this.sessions.get(id);
  }
}
EOF

      - name: Write IO protocol
        run: |
          cat > max-orchestrator/src/io/types.ts << 'EOF'
export interface IOMessage {
  id: string;
  type: string;
  channel: string;
  payload: unknown;
  userId: string;
  sessionId: string;
  timestamp: string;
}
EOF

          cat > max-orchestrator/src/io/MAXIOProtocol.ts << 'EOF'
import { IOMessage } from "./types";

export class MAXIOProtocol {
  async send(message: IOMessage): Promise<void> {
    return;
  }

  async receive(): Promise<IOMessage | null> {
    return null;
  }
}
EOF

      - name: Write autogen layer
        run: |
          cat > max-orchestrator/src/autogen/types.ts << 'EOF'
import { ModuleInput, ModuleOutput } from "../modules/types";

export interface AutogenPlanStep {
  moduleId: string;
  description: string;
}

export interface AutogenPlan {
  id: string;
  steps: AutogenPlanStep[];
}
EOF

          cat > max-orchestrator/src/autogen/MAXAutogenerator.ts << 'EOF'
import { ModuleRegistry } from "../modules/ModuleRegistry";
import { MAXMemoryGraph } from "../graph/MAXMemoryGraph";
import { AutogenPlan } from "./types";
import { ModuleInput, ModuleOutput } from "../modules/types";

export class MAXAutogenerator {
  private registry: ModuleRegistry;
  private graph: MAXMemoryGraph;

  constructor(registry: ModuleRegistry, graph: MAXMemoryGraph) {
    this.registry = registry;
    this.graph = graph;
  }

  createPlan(input: ModuleInput): AutogenPlan {
    const candidates = this.registry.findByInputType(input.type);
    return {
      id: `plan-${Date.now()}`,
      steps: candidates.map((m) => ({
        moduleId: m.id,
        description: `Run module ${m.id} for type ${input.type}`
      }))
    };
  }

  async executePlan(plan: AutogenPlan, input: ModuleInput): Promise<ModuleOutput[]> {
    const outputs: ModuleOutput[] = [];
    for (const step of plan.steps) {
      const module = this.registry.get(step.moduleId);
      if (!module) continue;
      const context = {
        userId: input.userId,
        sessionId: input.sessionId,
        runId: input.runId ?? `run-${Date.now()}`,
        state: {},
        dfpState: "default",
        timestamp: new Date().toISOString()
      };
      const out = await module.run(input, context);
      outputs.push(out);
    }
    return outputs;
  }
}
EOF

      - name: Write experience layer
        run: |
          cat > max-orchestrator/src/experience/types.ts << 'EOF'
import { ModuleOutput } from "../modules/types";

export interface ExperienceEvent {
  id: string;
  userId: string;
  sessionId: string;
  type: string;
  payload: unknown;
  createdAt: string;
}

export interface ExperienceRenderResult {
  channel: string;
  content: unknown;
  metadata?: Record<string, unknown>;
  source: ModuleOutput;
}
EOF

          cat > max-orchestrator/src/experience/MAXExperienceLayer.ts << 'EOF'
import { MAXMemoryGraph } from "../graph/MAXMemoryGraph";
import { MAXStateEngine } from "../state/MAXStateEngine";
import { MAXUserModel } from "../user/MAXUserModel";
import { ExperienceEvent, ExperienceRenderResult } from "./types";
import { ModuleOutput } from "../modules/types";

export class MAXExperienceLayer {
  private graph: MAXMemoryGraph;
  private state: MAXStateEngine;
  private users: MAXUserModel;

  constructor(graph: MAXMemoryGraph, state: MAXStateEngine, users: MAXUserModel) {
    this.graph = graph;
    this.state = state;
    this.users = users;
  }

  recordEvent(event: ExperienceEvent): void {
    return;
  }

  render(output: ModuleOutput): ExperienceRenderResult {
    return {
      channel: "default",
      content: output.payload,
      metadata: { tags: output.tags ?? [] },
      source: output
    };
  }
}
EOF

      - name: Write orchestrator core
        run: |
          cat > max-orchestrator/src/orchestrator/MAXOrchestrator.ts << 'EOF'
import { ModuleRegistry } from "../modules/ModuleRegistry";
import { MAXMemoryGraph } from "../graph/MAXMemoryGraph";
import { MAXStateEngine } from "../state/MAXStateEngine";
import { MAXUserModel } from "../user/MAXUserModel";
import { MAXIOProtocol } from "../io/MAXIOProtocol";
import { MAXAutogenerator } from "../autogen/MAXAutogenerator";
import { MAXExperienceLayer } from "../experience/MAXExperienceLayer";
import { ModuleInput, ModuleOutput } from "../modules/types";

export class MAXOrchestrator {
  constructor(
    private registry: ModuleRegistry,
    private graph: MAXMemoryGraph,
    private state: MAXStateEngine,
    private users: MAXUserModel,
    private io: MAXIOProtocol,
    private autogen: MAXAutogenerator,
    private experience: MAXExperienceLayer
  ) {}

  async handle(input: ModuleInput): Promise<ModuleOutput[]> {
    const plan = this.autogen.createPlan(input);
    const outputs = await this.autogen.executePlan(plan, input);
    return outputs;
  }
}
EOF

      - name: Write basic public files
        run: |
          cat > max-orchestrator/public/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>MAX Orchestrator</title>
</head>
<body>
  <div id="root">MAX Orchestrator ready.</div>
</body>
</html>
EOF

      - name: Write JSON data files
        run: |
          echo '[]' > max-orchestrator/data/graph-nodes.json
          echo '[]' > max-orchestrator/data/graph-edges.json
          echo '{}' > max-orchestrator/data/users.json
          echo '{}' > max-orchestrator/data/states.json
          echo '[]' > max-orchestrator/data/runs.json

      - name: Commit orchestrator
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add max-orchestrator
          git commit -m "Generate MAX Orchestrator"
          git push
